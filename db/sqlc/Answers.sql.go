// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: Answers.sql

package db

import (
	"context"
)

const createAnswer = `-- name: CreateAnswer :one
INSERT INTO "Answer" (user_id, question_id, content) VALUES ($1, $2, $3) RETURNING id, user_id, question_id, content, created_at, updated_at
`

type CreateAnswerParams struct {
	UserID     int32  `json:"user_id"`
	QuestionID int32  `json:"question_id"`
	Content    string `json:"content"`
}

func (q *Queries) CreateAnswer(ctx context.Context, arg CreateAnswerParams) (Answer, error) {
	row := q.db.QueryRowContext(ctx, createAnswer, arg.UserID, arg.QuestionID, arg.Content)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAnswerById = `-- name: DeleteAnswerById :one
DELETE FROM "Answer"
WHERE id = $1 RETURNING id, user_id, question_id, content, created_at, updated_at
`

func (q *Queries) DeleteAnswerById(ctx context.Context, id int32) (Answer, error) {
	row := q.db.QueryRowContext(ctx, deleteAnswerById, id)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAnswerByQuestionId = `-- name: DeleteAnswerByQuestionId :exec
DELETE FROM "Answer" 
WHERE question_id=$1
`

func (q *Queries) DeleteAnswerByQuestionId(ctx context.Context, questionID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAnswerByQuestionId, questionID)
	return err
}

const deleteAnswerByUserId = `-- name: DeleteAnswerByUserId :exec
DELETE FROM "Answer"
WHERE user_id= $1
`

func (q *Queries) DeleteAnswerByUserId(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAnswerByUserId, userID)
	return err
}

const getAnswerByID = `-- name: GetAnswerByID :one
SELECT id, user_id, question_id, content, created_at, updated_at FROM "Answer" WHERE id = $1
`

func (q *Queries) GetAnswerByID(ctx context.Context, id int32) (Answer, error) {
	row := q.db.QueryRowContext(ctx, getAnswerByID, id)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnswerForUpdate = `-- name: GetAnswerForUpdate :one
SELECT id, user_id, question_id, content, created_at, updated_at FROM "Answer" WHERE id = $1 LIMIT 1 For No Key Update
`

func (q *Queries) GetAnswerForUpdate(ctx context.Context, id int32) (Answer, error) {
	row := q.db.QueryRowContext(ctx, getAnswerForUpdate, id)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnswersByQuestionID = `-- name: GetAnswersByQuestionID :many
SELECT id, user_id, question_id, content, created_at, updated_at FROM "Answer" WHERE question_id = $1 and user_id=$4 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type GetAnswersByQuestionIDParams struct {
	QuestionID int32 `json:"question_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	UserID     int32 `json:"user_id"`
}

func (q *Queries) GetAnswersByQuestionID(ctx context.Context, arg GetAnswersByQuestionIDParams) ([]Answer, error) {
	rows, err := q.db.QueryContext(ctx, getAnswersByQuestionID,
		arg.QuestionID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Answer{}
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.QuestionID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnswersByQuestionID = `-- name: UpdateAnswersByQuestionID :one
Update "Answer"
Set content=$3, updated_at = now() WHERE id = $1 AND 
user_id=$2 
RETURNING id, user_id, question_id, content, created_at, updated_at
`

type UpdateAnswersByQuestionIDParams struct {
	ID      int32  `json:"id"`
	UserID  int32  `json:"user_id"`
	Content string `json:"content"`
}

func (q *Queries) UpdateAnswersByQuestionID(ctx context.Context, arg UpdateAnswersByQuestionIDParams) (Answer, error) {
	row := q.db.QueryRowContext(ctx, updateAnswersByQuestionID, arg.ID, arg.UserID, arg.Content)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
